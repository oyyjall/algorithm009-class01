学习笔记

一、哈希表、映射、集合：
   这一课的学习对哈希表的认识又加深了，以前只知道哈希表可以去重，现在更清晰的认识到哈希表实质上是通过建立映射来达到统计的目的，例如【LeetCode 205 同构字符串】和【LeetCode 290 单词规律】都利用到哈希表的映射规律。
   哈希表的查询、添加、删除大部分情况下都是O(1)，最坏情况（哈希函数选的不好或哈希表的整个size太小），会导致经常发生冲突，发生冲突时就会退化成一个链表，时间复杂度也就变成了O(n)。
   真正的工程代码里，经常用的不再是哈希表，而是由哈希表抽象出的map和set，对应到python就是dict（字典）和set（集合）。【set也可以用来去重】
   以前做题只会用最基础的dict，这次通过进一步学习，掌握了defaultdict和Counter的基本使用，这两个函数比dict更好用：
————defaultdict()括号里如果什么都不写，功能就跟dict一样。但是若想不一样，就要传入相应的函数变量，比如：传入int，默认返回0；传入list，默认返回[]；传入str，默认返回''。使用时需要导入【from collections import defaultdict】
————Counter()是一个 dict 的子类，用于计数可哈希对象和可迭代对象（如：列表）。它是一个集合，元素像字典键(key)一样存储，它们的计数存储为值。计数可以是任何整数值，包括0和负数。使用时也需要导入【from collections import Counter】

二、树、二叉树、二叉搜索树
   树这个知识块是个比较难啃的骨头，有段时间专门做这一个专题，没有总结出很多规律，不过倒是把二叉树的DFS（前中后序遍历的递归+迭代）和BFS（层次遍历，锯齿形遍历）研究了一下，有规律可寻。
   二叉树的深度优先遍历（递归法）：https://blog.csdn.net/oyall520/article/details/104917641
   二叉树的深度优先遍历（迭代法）：https://blog.csdn.net/oyall520/article/details/104828561
   二叉树里面最有意思的就是二叉搜索树了，二叉搜索树的中序遍历是一个升序序列，这是很多题目解题的关键；左子树的所有节点都小于根节点，右子树的所有节点都大于根节点————【寻找最近公共祖先】这题就要利用到这个性质。
   
三、堆、二叉堆、图
   二叉堆是堆的一种常见且简单的实现，但并不是最优的实现，所以二叉堆很多时候并不那么实用。所以在工程代码中直接调用优先队列就行，对于优先队列，python里有第三方库帮忙实现。
   二叉堆：找最大值或最小值时间复杂度是O(1)，但是它的删除和插入操作时间复杂度就是O(logN)
   作业里顺带附上了用python实现的堆的实现的代码【oyyj-heap.py】，还请老师批评指正。
