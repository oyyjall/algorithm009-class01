学习笔记
第一部分：数组、链表和跳表
  （1）数组的访问很方便，可以通过数组下标定位到任何一个位置，时间复杂度是O(1)；在数组尾部追加元素也是O(1)的时间复杂度。
    但是数组的插入和删除就没有那么方便了，比如插入到i位置，要将包括i在内后面所有的元素全部向后栘一格；删除就刚好相反，删除i位置的元素，要将i后面的元素向前移动一格。时间复杂度均为O(n)。
  （2）链表相对于数组来说，插入和删除都方便很多，不用改动原有的结构，时间复杂度是O(1)；
    但是链表的访问就没有数组那么直接了，它只能从首节点开始，通过next指针一步步往后找，时间复杂度是O(n)
   所以没有十全十美的数据结构，使用哪种结构要视情况而定。
   
   链表的题目印象最深的就是【反转链表】，因为这一题前前后后做了四遍都不会，现在总算是清楚了。类似的题目还有【两两交换链表中的节点】、【k个一组反转链表】，这些题目的套路都挺相似的，最重要的一点就是画图，画图思考，画清楚反转的过程，这样写代码就会很清晰了。
  【环形链表】最经典的解法就是双指针（准确点说是快慢指针），慢指针每次走一步，快指针每次走两步，当两个指针相遇了就表示链表中有环，相遇的地方就是环入口。
   
第二部分：栈、队列、优先队列、双端队列
  （1）栈：先进后出，若一个东西具有最近相关性，就用栈来解决。很多现实中的事情，反映到工程中具有由外向内或从内向外逐渐扩散的特性，且最外层和最外层是一对，最内层和最内层是一对，类似于洋葱，碰见这种结构就要想到用栈来解决。
      有时候可以用两个栈解决一些特殊的数据结构问题，比如用栈来实现队列：就是用两个栈，每次先进后出就压到另外一个栈去（即先将所有元素压入栈1，当栈2为空时，依次弹出栈1的元素，并且随之压入栈2），就可以达到队列的效果；
      或者只用队列实现栈：就是用两个队列，每次先进先出就去到另外一个队列再弹出去。
      
   栈的题目印象最深的就是【柱状图中最大的矩形】了，涉及到单调栈的问题，维护一个单调递增栈，当遍历到的元素大于栈顶元素时就入栈，否则就弹出栈顶元素并进行相关的计算操作。
  （2）队列：先进先出，因为python里没有直接的栈和队列这种结构，本质上都是一个列表，就是使用的时候有区别。
  （3）优先队列：插入操作是O(1), 取出操作是O(logN)——是按照元素的优先级取出的（根据元素的重要性，每次取最大值 or 最小值），底层具体实现的数据结构复杂多样，可以用heap（但也不一定是二叉堆，可以是斐波那契堆或其他堆）；也可以是BST（可以是平衡的二叉搜索树，比如：红黑树或AVL）。
  
这次作业使用的最多的应该就是双指针了，特别是在处理一个有序数组时要首先想到双指针（对撞指针 or 快慢指针），并且使用双指针循环的代码也要写的超级熟练，一般就三种情况————
    （1）i和j不断往左右两边扩散；
    （2）i和j不断往中间推进，最后相遇；
    （3）i和j写两个嵌套的循环枚举所有可能的i和j的情况。
      
