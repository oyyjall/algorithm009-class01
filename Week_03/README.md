学习笔记

这一周的递归和回溯是很薄弱的一个知识块，以前做题最怕递归，因为想不明白到底是怎么一层层运行的，有时候甚至人肉递归，画图或者手写这一层的结果是什么，树的专题做了50多道题，除了BFS的解法都用到了递归，做完还是云里雾里，主要原因：一是没有真正理解递归，二是超哥之前提到的最大的误区（做题只做一遍），做完就忘。

递归的思维要点：（1）最大误区：不要进行“人肉递归”；（2）要找到最近最简方法【也就是最近重复子问题】，将其拆解为可重复解决的问题（重复子问题）；（3）有些递归的题目可以用数学归纳法找规律。
牢记超哥讲的递归代码模板：（1）找递归终止条件；（2）处理当前层逻辑；（3）下探到下一层（因为这一层解决完了肯定要到下一层去）；（4）清理当前层的状态（这一步有时候需要：比如回溯时，有时候不需要，视具体情况而定）

对于树来说，解法一般是递归，因为树的定义没有所谓的后继结构或者一个便于循环的结构，更多的是左节点和右节点，这样要访问它的子树的话，最好的一种方法就是直接对它的左节点和右节点再调用相同的遍历函数，也就是所谓的递归。总的来说，树的题型要使用递归，是因为：（1）节点的定义；（2）重复性（也叫自相似性）。

而回溯的本质就是递归，解决一个回溯问题，就是解决一个决策树的遍历过程。回溯法的python代码模板如下：


result = []

def backtrack(路径，选择列表):

    if (满足结束条件):
    
        result.append(路径)
        
        return
        
    for 选择 in 选择列表:
    
        做选择
        
        backtrack(路径，选择列表)
        
        撤销选择
        
这个框架中，（1）路径：表示已经做出的选择；（2）选择列表：表示当前可以做的选择；（3）结束条件：表示到达决策树底层，无法再做选择的条件（通俗点说就是递归终止条件）。而框架的核心就是for循环部分，我们在递归调用前【做选择】，在递归调用后【撤销选择】。

回溯法最经典的题目莫过于【子集/全排列/组合】这三大类型了，不理解清楚很容易混淆，组合问题相对于好一点；子集和全排列涉及到重复性，也就是说如果数组中不包含重复的元素，那么解题思路就比较清晰，套用上面的回溯算法框架，适当修改即可；但是一旦涉及到重复性，就要考虑去重，这时需要先将数组排序，这样便于相同的数字挨在一起容易去重，最近做题遇见最多的去重的条件就是【if i > 0 and nums[i] == nums[i-1]】，感觉好像是一个规律，虽然暂时没想明白为什么，不过做题要会用就好啦。
